/*
 * VotingReputation Client Version 1 Addons autogenerated by
 * @colony/colony-js version 4.0.0-beta.0 from colonyNetwork tag 'clwss'
 *
 * Feel free to modify as needed!
 */

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any */

import {
  constants,
  ContractTransaction,
  BigNumberish,
  BigNumber,
  BytesLike,
  Overrides,
} from 'ethers';

import {
  AugmentedIColony,
  getPermissionProofs,
  getChildIndex,
} from '../../../Core/augments/commonAugments';
import { ColonyRole } from '../../../../types';

import { VotingReputationClient } from './VotingReputationClient';

const { MaxUint256 } = constants;

/*
 * Extra client methods
 */
export const getVotingReputationClientAugments = (
  votingReputationClient: VotingReputationClient,
  colonyClient: AugmentedIColony,
): Record<string, any> => ({
  createDomainMotionWithProofs: async (
    _domainId: BigNumberish, // Domain in which the voting will take place in
    _action: BytesLike,
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
    overrides?: Overrides,
  ): Promise<any> => {
    let childSkillIdex = MaxUint256;
    const votingDomain = BigNumber.from(_domainId);
    const decodedDomain = BigNumber.from(
      `0x${_action.toString().slice(10, 74)}`,
    ); // Domain in which we have permissions
    if (!decodedDomain.eq(votingDomain)) {
      const domainSkillIdIndex = await getChildIndex(
        colonyClient,
        decodedDomain,
        votingDomain,
      );
      if (!domainSkillIdIndex.eq(BigNumber.from(-1))) {
        childSkillIdex = BigNumber.from(domainSkillIdIndex);
      } else {
        throw new Error('Child skill index could not be found');
      }
    }
    return votingReputationClient.createDomainMotion(
      votingDomain,
      childSkillIdex,
      _action,
      _key,
      _value,
      _branchMask,
      _siblings,
      overrides,
    );
  },
  stakeMotionWithProofs: async (
    _motionId: BigNumberish,
    _vote: BigNumberish,
    _amount: BigNumberish,
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
    overrides?: Overrides,
  ): Promise<ContractTransaction> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const [permissionDomainId, childSkillIndex] = await getPermissionProofs(
      colonyClient,
      domainId,
      ColonyRole.Arbitration,
      votingReputationClient.address,
    );
    return votingReputationClient.stakeMotion(
      _motionId,
      permissionDomainId,
      childSkillIndex,
      _vote,
      _amount,
      _key,
      _value,
      _branchMask,
      _siblings,
      overrides,
    );
  },
  escalateMotionWithProofs: async (
    _motionId: BigNumberish,
    _newDomainId: BigNumberish, // parent, or ancestor, domain id
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
    overrides?: Overrides,
  ): Promise<ContractTransaction> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const motionDomainChildSkillIdIndex = await getChildIndex(
      colonyClient,
      BigNumber.from(_newDomainId),
      domainId,
    );
    if (motionDomainChildSkillIdIndex.toNumber() === -1) {
      throw new Error('Child skill index could not be found');
    }
    return votingReputationClient.escalateMotion(
      _motionId,
      _newDomainId,
      motionDomainChildSkillIdIndex,
      _key,
      _value,
      _branchMask,
      _siblings,
      overrides,
    );
  },
  claimRewardWithProofs: async (
    _motionId: BigNumberish,
    _staker: string,
    _vote: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const [permissionDomainId, childSkillIndex] = await getPermissionProofs(
      colonyClient,
      domainId,
      ColonyRole.Arbitration,
      votingReputationClient.address,
    );
    return votingReputationClient.claimReward(
      _motionId,
      permissionDomainId,
      childSkillIndex,
      _staker,
      _vote,
      overrides,
    );
  },
});

/*
 * Extra client methods estimates
 *
 * These are needed! Don't skip them!
 */
export const getVotingReputationClientEstimateAugments = (
  votingReputationClient: VotingReputationClient,
  colonyClient: AugmentedIColony,
): Record<string, any> => ({
  createDomainMotionWithProofs: async (
    _domainId: BigNumberish, // Domain in which the voting will take place in
    _action: BytesLike,
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
  ): Promise<BigNumber> => {
    let childSkillIdex = MaxUint256;
    const votingDomain = BigNumber.from(_domainId);
    const decodedDomain = BigNumber.from(
      `0x${_action.toString().slice(10, 74)}`,
    ); // Domain in which we have permissions
    if (!decodedDomain.eq(votingDomain)) {
      const domainSkillIdIndex = await getChildIndex(
        colonyClient,
        decodedDomain,
        votingDomain,
      );
      if (!domainSkillIdIndex.eq(BigNumber.from(-1))) {
        childSkillIdex = BigNumber.from(domainSkillIdIndex);
      } else {
        throw new Error('Child skill index could not be found');
      }
    }
    return votingReputationClient.estimateGas.createDomainMotion(
      votingDomain,
      childSkillIdex,
      _action,
      _key,
      _value,
      _branchMask,
      _siblings,
    );
  },
  stakeMotionWithProofs: async (
    _motionId: BigNumberish,
    _vote: BigNumberish,
    _amount: BigNumberish,
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
  ): Promise<BigNumber> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const [permissionDomainId, childSkillIndex] = await getPermissionProofs(
      colonyClient,
      domainId,
      ColonyRole.Arbitration,
      votingReputationClient.address,
    );
    return votingReputationClient.estimateGas.stakeMotion(
      _motionId,
      permissionDomainId,
      childSkillIndex,
      _vote,
      _amount,
      _key,
      _value,
      _branchMask,
      _siblings,
    );
  },
  escalateMotionWithProofs: async (
    _motionId: BigNumberish,
    _newDomainId: BigNumberish, // parent, or ancestor, domain id
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
  ): Promise<BigNumber> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const motionDomainChildSkillIdIndex = await getChildIndex(
      colonyClient,
      BigNumber.from(_newDomainId),
      domainId,
    );
    if (motionDomainChildSkillIdIndex.toNumber() === -1) {
      throw new Error('Child skill index could not be found');
    }
    return votingReputationClient.estimateGas.escalateMotion(
      _motionId,
      _newDomainId,
      motionDomainChildSkillIdIndex,
      _key,
      _value,
      _branchMask,
      _siblings,
    );
  },
  claimRewardWithProofs: async (
    _motionId: BigNumberish,
    _staker: string,
    _vote: BigNumberish,
  ): Promise<BigNumber> => {
    const { domainId } = await votingReputationClient.getMotion(_motionId);
    const [permissionDomainId, childSkillIndex] = await getPermissionProofs(
      colonyClient,
      domainId,
      ColonyRole.Arbitration,
      votingReputationClient.address,
    );
    return votingReputationClient.estimateGas.claimReward(
      _motionId,
      permissionDomainId,
      childSkillIndex,
      _staker,
      _vote,
    );
  },
});

/* eslint-enable */
